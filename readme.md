/bin/python3 /home/andy/goit/hw912.py
Жадібний алгоритм для суми 75:
Кількість монет: {50: 1, 25: 1}
Час виконання: 0.000015020

Алгоритм динамічного програмування для суми 75:
Кількість монет: {50: 1, 25: 1}
Час виконання: 0.000079393

Жадібний алгоритм для суми 1980:
Кількість монет: {50: 39, 25: 1, 5: 1}
Час виконання: 0.000003099

Алгоритм динамічного програмування для суми 1980:
Кількість монет: {50: 39, 25: 1, 5: 1}
Час виконання: 0.002603769

Жадібний алгоритм для суми 10560:
Кількість монет: {50: 211, 10: 1}
Час виконання: 0.000003099

Алгоритм динамічного програмування для суми 10560:
Кількість монет: {50: 211, 10: 1}
Час виконання: 0.015826941

Жадібний алгоритм для суми 15820:
Кількість монет: {50: 316, 10: 2}
Час виконання: 0.000004768

Алгоритм динамічного програмування для суми 15820:
Кількість монет: {50: 316, 10: 2}
Час виконання: 0.027185440

Висновки:
Після виконання замірів часу виконання обидвох алгоритмів для чотирьох різних сум можемо зробити наступні висновки:

Жадібний алгоритм:

Час виконання: Жадібний алгоритм показав відносно швидкі результати для усіх чотирьох сум.
Ефективність: Жадібний алгоритм працює добре для великої кількості малих сум, але може виявити себе менш ефективним для дуже великих сум.
Алгоритм динамічного програмування:

Час виконання: Алгоритм динамічного програмування зазвичай має більший час виконання порівняно з жадібним алгоритмом, особливо для великих сум.
Оптимальність: Динамічне програмування гарантує оптимальний результат для будь-якої суми та набору монет, але зазвичай потребує більше обчислювальних ресурсів.
Загалом, обидва алгоритми мають свої переваги та недоліки, і вибір між ними залежить від конкретних вимог проекту та обсягу даних.